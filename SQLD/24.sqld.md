# 제4절 서브쿼리

- 하나의 SQL문 안에 포함되어 있는 또 다른 SQL문
- 알려지지 않은 기준을 이용한 검색을 위해 사용
- 메인쿼리가 서브쿼리를 포함하는 종속적인 관계
- 서브쿼리는 메인쿼리의 칼럼을 모두 사용할 수 있지만 메인쿼리는 서브쿼리의 칼럼을 사용할 수 없음
- 질의 결과에 서브쿼리 칼럼을 표시해야 한다면 조인 방식으로 변환하거나 함수, 스칼라 서브쿼리 등을 사용해야 함
- 서브쿼리를 사용할 때 주의할 사항
    1. 서브쿼리를 괄호로 감싸서 사용
    2. 단일 행 또는 복수 행 비교 연산자와 함께 사용 가능
    3. ORDER BY 사용 불가
- 서브쿼리가 SQL 문에서 사용 가능한 곳
    - SELECT 절, FROM 절, WHERE 절, HAVING 절, ORDER BY 절, INSERT문의 VALUES 절, UPDATE문의 SET 절
- 동작하는 방식에 따른 서브쿼리 분류

    |서브쿼리 종류|설명|
    |---|---|
    |Un-Correlated (비연관) 서브쿼리|- 서브쿼리가 메인쿼리 칼럼을 가지고 있지 않은 형태의 서브쿼리<br/>- 메인쿼리에 값을 제공하기 위한 목적으로 주로 사용|
    |Correlated (연관) 서브쿼리|- 서브쿼리가 메인쿼리 칼럼을 가지고 있는 형태의 서브쿼리<br/>- 일반적으로 메인쿼리가 먼저 수행되어 읽혀진 데이터를 서브쿼리에서 조건이 맞는지 확인하고자 할 때 주로 사용|

- 반환되는 데이터의 형태에 따른 서브쿼리 분류

    |서브쿼리 종류|설명|
    |---|---|
    |단일 행 (Single Row) 서브쿼리|- 서브쿼리의 실행 결과가 항상 1건 이하인 서브쿼리<br/>- 단일 행 비교 연산자와 함께 사용<br/>- 단일 행 비교 연산자 : =. <. <=, >, >=, <>|
    |다중 행 (Multi Row) 서브쿼리|- 서브쿼리의 실행 결과가 여러 건인 서브쿼리<br/>- 다중 행 비교 연산자와 함께 사용<br/>- 다중 행 비교 연산자 : IN, ALL, ANY, SOME, EXISTS|
    |다중 칼럼 (Multi Column) 서브쿼리|- 서브쿼리의 실행 결과로 여러 칼럼 반환<br/>- 메인쿼리의 조건절에 여러 칼럼 동시 비교 가능<br/>- 서브쿼리와 메인쿼리에서 비교하고자 하는 칼럼 개수와 칼럼 위치가 동일해야 함|

## 1. 단일 행 서브 쿼리

- 서브쿼리의 결과 건수가 반드시 1 이하
- 단일 행 비교 연산자 (=, <, <=, >, >=, <>) 와 함께 사용

## 2. 다중 행 서브 쿼리

- 서브쿼리의 실행 결과가 여러 건인 서브쿼리
- 다중 행 비교 연산자 (IN, ALL, ANY, SOME, EXISTS)와 함께 사용

    |다중 행 연산자|설명|
    |:---:|---|
    |IN (서브쿼리)|서브쿼리의 결과에 존재하는 임의의 값과 동일한 조건을 의미 (Multiple OR 조건)|
    |비교연산자 ALL (서브쿼리)|서브쿼리의 결과에 존재하는 모든 값을 만족하는 조건|
    |비교연산자 ANY (서브쿼리)|서브쿼리의 결과에 존재하는 어느 하나의 값이라도 만족하는 조건|
    |EXISTS (서브쿼리)|서브쿼리의 결과를 만족하는 값이 존재하는지 여부를 확인하는 조건|

## 3. 다중 칼럼 서브쿼리

- 서브쿼리의 결과로 여러 개의 칼럼이 반환되어 메인쿼리의 조건과 동시에 비교되는 것
- SQL Server에서는 지원되지 않는 기능

## 4. 연관 서브쿼리

- 서브쿼리 내에 메인쿼리 칼럼이 사용된 서브쿼리
- EXISTS 서브쿼리는 항상 연관 서브쿼리로 사용됨

## 5. 그 밖에 위치에서 사용하는 서브쿼리

### 1. SELECT 절에서 서브쿼리 사용하기 ⇒ 스칼라 서브쿼리

- 한 행, 한 칼럼만 반환하는 서브쿼리
- 칼럼을 쓸 수 있는 대부분의 곳에서 사용 가능
- 단일 행 서브쿼리이기 때문에 결과가 2건 이상 반환되면 SQL문은 오류 반환

### 2. FRPOM 절에서 서브쿼리 사용하기 ⇒ 인라인 뷰 (Inline View)

- 서브쿼리의 결과가 마치 실행 시에 동적으로 생성된 테이블인 것처럼 사용
- 임시적으로 생성되는 동적인 뷰
- 데이터베이스에 해당 정보가 저장되지 않음
- ORDER BY절 사용 가능
- TOP-N 쿼리 : 인라인 뷰에서 먼저 정렬을 수해앟고 정렬된 결과 중 일부 데이터를 추출하는 것 (Oracle의 ROWNUM과 동일)

### 3. HAVING 절에서 서브쿼리 사용하기

- 그룹 함수와 함께 사용될 때 그룹핑된 결과에 대해 부가적인 조건을 주기 위해 사용

### 4. UPDATE 문의 SET 절에서 사용

```sql
UPDATE TEAM A
SET A.STADIUM_NAME = (SELECT X.STADIUM_NAME
                      FROM STADIUM X
                      WHERE X.STADIUM_ID = A.STADIUM_ID);
```

- 서브쿼리를 사용한 변경 작업을 할 때 서브쿼리의 결과가 NULL을 반환할 경우 해당 컬러므이 결과가 NULL이 될 수 있음에 주의

### 5. INSERT 문의 VALUES 절에서 사용하기

```sql
INSERT INTO PLAYER(PLAYER_ID, PLAYER_NAME, TEAM_ID)
VALUES ((SELECT TO_CHAR(MAX(TO_NUMBER(PLAYER_ID))+1) FROM PLAYER), '홍길동', 'K06');
```

## 6. 뷰 (View)

- 실제 데이터를 가지고 있지 않음
- 뷰 정의 (View Definition)만 가지고 있음
- 질의에서 뷰가 사용되면 뷰 정의를 참조해서 DBMS 내부적으로 질의를 재작성 (Rewrite) 하여 질의 수행
- 테이블이 수행하는 역할을 수행하기 때문에 가상 테이블 (Virtual Table) 이라고도 함
- 뷰 사용의 장점

    |뷰의 장점|설명|
    |:---:|---|
    |독립성|테이블 구조가 변경되어도 뷰를 사용하는 응용 프로그램은 변경하지 않아도 됨|
    |편리성|복잡한 질의를 뷰로 생성함으로써 관련 질의를 단순하게 작성 가능|
    |보안성|숨기고 싶은 정보에 대한 칼럼을 빼고 생섬함으로써 사용자에게 정보를 감출 수 있음|

- 뷰 생성 (CREATE VIEW 문)

    ```sql
    CREATE VIEW V_PLAYER_TEAM
    AS SELECT P.PLAYER_NAME, P.POSITION, P.BACK_NO, P.TEAM_ID, T.TEAM_NAME
       FROM PLAYER P, TEAM T
       WHERE P.TEAM_ID = T.TEAM_ID;
    ```

- 뷰 제거 (DROP VIEW 문)

    ```sql
    DROP VIEW V_PLAYER_TEAM;
    ```

    
> 본 포스팅은 SQL 개발자 가이드를 참고하여 작성되었습니다.